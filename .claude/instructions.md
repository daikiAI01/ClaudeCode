# MCP活用ガイドライン

接続されているMCPサーバーを積極的に活用してください。以下の各MCPの役割を理解し、タスクに応じて自発的に使用してください。

## MCPサーバーの役割と活用方針

### 1. serena（セマンティックコード解析・編集）
- **活用場面**: コードの理解、編集、リファクタリング
- **優先度**: 高 - コード関連タスクでは最優先で使用
- **具体例**:
  - コードベースの構造理解時: `get_symbols_overview`, `find_symbol`を使用
  - コード編集時: `replace_symbol_body`, `insert_after_symbol`を使用
  - 関数/クラスの参照確認: `find_referencing_symbols`を使用
- **注意**: ファイル全体を読む前に、まずシンボルベースで必要な部分だけを読む

### 2. memory（ナレッジグラフ）
- **活用場面**: プロジェクト情報の記録・参照、コンテキスト管理
- **優先度**: 中〜高 - 複雑なタスクや継続的な作業で活用
- **具体例**:
  - プロジェクトのアーキテクチャ理解を記録: `create_entities`, `create_relations`
  - 過去の学習内容を参照: `read_graph`, `search_nodes`
  - 重要な決定事項を記録: `add_observations`

### 3. supabase
- **活用場面**: Supabaseプロジェクトの管理・操作
- **優先度**: タスク依存 - Supabase関連タスクで必須
- **具体例**:
  - データベース操作: `execute_sql`, `apply_migration`
  - プロジェクト管理: `list_projects`, `get_project`
  - Edge Functions: `deploy_edge_function`

### 4. filesystem
- **活用場面**: ファイルシステム操作
- **優先度**: 中 - serenaで対応できない場合に使用
- **具体例**:
  - ディレクトリ構造の把握: `directory_tree`, `list_directory`
  - ファイル検索: `search_files`
  - バイナリファイルやメディアファイルの操作: `read_media_file`

### 5. playwright（ブラウザ自動化）
- **活用場面**: Web UIのテスト、スクレイピング、自動化
- **優先度**: タスク依存 - Web関連タスクで使用
- **具体例**:
  - UIテスト: `browser_navigate`, `browser_click`
  - スクリーンショット取得: `browser_take_screenshot`
  - フォーム操作: `browser_fill_form`

### 6. sequential-thinking
- **活用場面**: 複雑な問題解決、段階的思考が必要な場面
- **優先度**: 中 - 複雑なタスクで適宜使用
- **具体例**:
  - 複雑なアルゴリズム設計
  - 多段階の問題分析
  - 仮説検証が必要な場面

### 7. ide
- **活用場面**: IDE統合機能
- **優先度**: 中 - 診断情報やJupyter操作で使用
- **具体例**:
  - エラー・警告の確認: `getDiagnostics`
  - Jupyterコード実行: `executeCode`

### 8. codex（AI駆動コード分析・問題解決）
- **活用場面**: 複雑なバグ解析、アーキテクチャ設計、詳細な技術相談
- **優先度**: 高 - 通常の手法で解決困難な場合に自動的に使用
- **具体例**:
  - 複雑なバグの根本原因分析: `codex`
  - アーキテクチャ設計の相談: `codex`
  - パフォーマンス問題の深堀り分析: `codex`
  - セキュリティ脆弱性の詳細調査: `codex`
- **注意**: Codexは独立したAIエージェントとして動作し、詳細な分析と提案を提供する

## Codex自動使用ルール

以下の状況では**自動的に**Codexを使用してください：

1. **バグ修正の失敗パターン**
   - 同じバグに対して3回以上修正を試みても解決しない場合
   - エラーの原因が複数のファイルやモジュールにまたがっている場合
   - エラーメッセージから原因が特定できない場合

2. **アーキテクチャ・設計相談**
   - 新機能の設計方針を決定する場合
   - システム全体のアーキテクチャ変更を検討する場合
   - パフォーマンス最適化の戦略を立てる場合
   - セキュリティ設計のレビューが必要な場合

3. **複雑な問題解析**
   - コードの動作が予期しない挙動を示す場合
   - デバッグに30分以上かかっている場合
   - 複数の技術スタックにまたがる問題の場合

4. **技術的判断が必要な場合**
   - ライブラリやフレームワークの選定
   - パフォーマンスとメンテナンス性のトレードオフ判断
   - リファクタリングの優先順位決定

### Codex使用の判断フロー

```
問題が発生
  ↓
通常の手法で解決を試みる
  ↓
[以下のいずれかに該当？]
- 3回以上失敗
- アーキテクチャ相談
- 複雑な問題
- 30分以上デバッグ
  ↓
YES → Codexを使用して詳細分析
  ↓
NO → 通常の手法を継続
```

### Codexとの連携例

```
ユーザー: 「このバグが直らない」
  ↓
Claude Code: 修正を試みる（1回目）
  ↓
失敗
  ↓
Claude Code: 別のアプローチで修正（2回目）
  ↓
失敗
  ↓
Claude Code: さらに別の方法で修正（3回目）
  ↓
失敗
  ↓
Claude Code: 「Codexで詳細分析します」
  ↓
Codex: 根本原因を分析し、解決策を提案
  ↓
Claude Code: Codexの提案を実装
```

## 基本原則

1. **自発的な判断**: ユーザーが明示的に指示しなくても、タスクに適したMCPを自動的に選択・使用する
2. **効率優先**: 複数のMCPで実現可能な場合、最も効率的な方法を選択する
3. **統合活用**: 複数のMCPを組み合わせて、より高度なタスクを実現する
4. **コンテキスト保存**: 重要な情報はmemoryに記録し、将来のタスクで活用する
5. **段階的エスカレーション**: 通常の手法で解決困難な場合、自動的にCodexを使用する

## 具体的な動作例

- **通常の実装タスク** → `serena`でコード編集、`memory`で情報記録
- **データベース関連タスク** → `supabase`を使用し、変更内容は`memory`に記録
- **Web UI関連** → `playwright`を使用
- **複雑な問題** → `sequential-thinking`で段階的に思考
- **バグが3回以上解決できない** → **自動的に`codex`で詳細分析**
- **アーキテクチャ設計相談** → **`codex`でベストプラクティス確認**
- **パフォーマンス問題** → **`codex`で最適化戦略を分析**

## タスク別の推奨フロー

### 通常の実装（Claude Codeで完結）
```
ユーザー要求 → serena（コード解析） → serena（編集） → 完了
```

### 複雑なバグ修正（Codex自動起動）
```
バグ報告 → 修正試行（1-3回） → 失敗 → Codex分析 → 解決策実装 → 完了
```

### アーキテクチャ設計（Codex優先）
```
設計相談 → Codex分析 → 設計案提示 → ユーザー確認 → 実装
```

**重要**: ユーザーが「このMCPを使って」と言わなくても、タスクの性質から適切なMCPを判断して積極的に活用してください。特にCodexは、上記のルールに該当する場合、**ユーザーへの通知とともに自動的に起動**してください。
